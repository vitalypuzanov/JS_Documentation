# ** Типы данных ** 

В JS существует 8 типов данных и 2 группы - примитивы и сложные структуры:
- number число (целые и с плавующей точкой) до 2 в 53 степени
- bigint для целых чисел большой длинны 
- string строка
- boolean (true/fakse)
- null дле неизвестных значений 
- undefind для неприсвоенных значений 
- symbol уникалный модификатор 
- object сложный тип 

**Что такое поднятие или hoastin?**

Переменные которые обьявленые внутри функции не всплывают , при обьявление переменной через const или лет мы можем получить ее значение только после обялвения иначе будет refference error

**Типы таймеров**
settimeout(fucn,time) - один раз по истечени 
setinterval(fuct,time) - вызывать постоянно черезе промежуток 

**ЧТо такое облость видимости ?**
- глобальная переменные и функции 
- локальные переменные внутри функции и доступная функциям внутри функциям 
- блочные let и const 

**Разница между cons let и var?**

var- всплывает и дает undefind при вызове 
let и const не всплывают и дают ошибку, также они блочные и доступные только внутри функции где объявлены

**Что такое функции высшего порядка?**
Это функции которые возравают другую функцию , или принимают функцию в качестве одного из агрумента (map foreach reduce )

**Что такое чистая функция?**
В ней нет побочных эффектов(dom запрос, вывод на экран) и она возращает тот же результат 
const abb =(x,y)=> x+y;
abb (4,4)

**Разница между .forEach и .map()?**
Методы масивов для перебора и каждому элементому испозьовать переданную функцию 
- map возвращает новый массив , 
- for Each перебирает массив и ничего не возвращает 

**Что обозначает «this» в JavaScript?**
Это контекст вызова или ссылка на значние объека , может принимать разные значение
При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
Эта функция может быть скопирована между объектами (из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является объект перед точкой.
Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри стрелочной функции обращаются к this, то его значение берётся снаружи.

**Разница между .call(), .apply() и bind()?**
- call (контекст, значение,значение,,значение,значение,) обычное пречисдение 
- aply (контекст [значение,значение, значение, значение,т]) передеается как массив
- bind функция обертка которую можно присвоеить в переменную и потом вызвать


**Как определить наличие свойства в объекте?**
существует 3 способа 
1) hasOwnProperty  синтаксиси console.log (obj.hasOwnProperty(prop)) результат тру\фалсе
2) in   синтаксиси console.log ('prop' in obj) результат тру\фалсе
3) напрямую через индекс 


**Что такое замыкание (Closure)?**
При создании функции переменные которые объявлены внутри функции, видны лишь внутри функции , но при этом вложенная внутри функции будет иметь доступ к перемнной 

**Что такое псевдомассив arguments?**
Это коллекция аргументов которая передается в функцию , это объект подобный массиву есть свойство lenght


**Почему результат сравнения 2х объектов это false?**
Примитивы сравниваются по значение в отличичии от объектов. Так как  объект это ссылочный тип данных.


**Что такое прототипное наследование? Как создать объект без прототипа?**
Это когда созданный объект ищет свойства если они не определены в своем прототипу. Для создания объекта без прототипа нужно использовать конструкцию 
Object.create


**Что такое NaN? Как определить, что значение равно NaN?**
Это not a number значение отличное от числа. получается когда математическая функция сработала неверно. NAN не равно ничему 
Для определения используется isNAN возвращает булевовое значение 


**Как в JavaScript создать объект?**
- Через литерал объекта {}
- Через Object.create
- Через функцию конструктор через New



**Для чего используется ключевое слово new?**
В основном мы испльзуев его для создания функции коструктора. Также выполняет 4 задачи:
- создает пустой объект
- привязывает контекст к объекту 
- функции получают свойства прототайп
- возвращает значение this 


**Для чего используется оператор !! (двойного отрицания)?**
Используется как и метод boolean of для приведения значения к булевому 

**Как проверить, является ли значение массивом?**
Существует специальный метод Array.isArray 

**Для чего используется оператор % (остатка)?**
Используется для получения остатка от деления 




 # DOM 

 Объектная модель документа которая браузер создает на основе html кода. Дом имеет древовидную структуру его еще называют дом дерево

 **Что такое распространение события (Event Propagation)?**

 События 3 фазы
- capture - захват начинается от корня до целевого элемента 
- target событи достигает целевого елемента
- bubling - высплытие событие возвращается обратно до window 

 **Что такое делегирование событий (Event Delegation)?**
 Прием когда вместо множества обработчиком ,можно добавить один на общего предка 

 **Разница между e.preventDefault() и e.stopPropagation()?**
 e.preventDefault() отключает поведение элемента по умолчанию
 e.stopPropagation() отключает распростронение событый 

 **Методы поиска элементов в DOM?**
document.getElementById)('id')
document.getElementName('name')
document.getElementByTagName('div')
document.getElementByClassName('class')
document.querySelector('nav+p')
document.querySelectorAll('nav > ul > li')


 **Разница между event.target и event.currentTarget?**


 **Разница между .stopPropagation() и .stopImmediatePropagation()?**
 .stopPropagation() отменяет дальнейшее всплытие но на текущем элементе обработчикик срабатывает
 .stopImmediatePropagation() отменяет вслытие и на текущем элементе

 **Разница между событиями load и DOMContentLoaded?**
 Двое срабатывает при загрузке страницы в браузере 
- DOMContentLoaded отрабатывает когда браузер полностью загрузил HTML а уже после чего был загружены стили css и скрипты еще не прогруждены 
- load событие когда бразуер загрузил и шрифты и стили и картики и т.д 


 **Разница между attribute и property у DOM-элементов?**
 - attribute статичная значение DOM атрибута которое не изменяемо и в большенстве своем может быть добавлено  в HTML разметка 
 - property вычесленное значение DOM елемента которое может динамически изменятся например поле инпут с типом VAlue


 **Разница между HTMLCollection и NodeList?**
 - HTMLCollection динамическая коллекция которая представляет собой масива подобный итерируемый объект дочерних элементов 
 -  NodeList статичский список узлов в который входит все найденный в документе элементы

  # Async JS:


**Разница между синхронными и асинхронными функциями?**
Синхонный функции выполняются сразу и последовательно. Асинхронные через определенный промежуток времени и не блокируют выполнениче скрипта.

**Что такое AJAX?**
Асинхонный джава скрипт и XML. Методология при который мы можем асинкронно запрашивать и получать данные с сервера 

**Что такое same-origin policy в контексте JavaScript?**

**Что такое цикл событий (event loop) и как он работает?**
event loop 
JS однопточный поэтому выделяется стек в котором хранятся перменные и функции и список событий формирует очередь. 

**Что такое промисы (Promises)?**
Подход к работе с ассинхронным кодом. 
есть 3 состояний
- fullfield - выполненно 
- rejected - откланенно
- pending - ожидает выполнения 



# Async defer #
- async	Порядок загрузки (кто загрузится первым, тот и сработает). Не имеет значения. Может загрузиться и выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кеше, а документ достаточно большой.
- defer Порядок документа (как расположены в документе). Выполняется после того, как документ загружен и обработан (ждёт), непосредственно перед DOMContentLoaded.



//////////////////////////////////////////////////////

Вопросы к собеседованию для Itechart 

ООП- методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования[1].
- Инкапсуляция - ограничение к данным. Поведение объекта объеденияются в одном классе при котором внутренняя реализация скрывается от пользователя а для работы с оббъектом используется открытый интерфейс. Getter и сеттеры
- Наследование - создание новых классов на осново существующих классов.
- Абстракция - выделение наиболее выжных характеристик и инфорация об объекте
- Полиморфизм - срособность функции работать с разными типами. изменение функционала базового класса в классе наследнике 

# 1 Cистема типов
В JavaScript есть 8 основных типов.

- number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
- bigint для целых чисел произвольной длины.
- string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
- boolean для true/false.
- null для неизвестных значений – отдельный тип, имеющий одно значение null.
- undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
- object для более сложных структур данных.
- symbol для уникальных идентификаторов.




// '', 0, null, undefined, NaN, false - неправдивые значения.


// Строки и числа
// console.log(1 + '2') // string 12
// console.log('' + 1 + 0) строка 10
// console.log('' - 1 + 0) -1 
// console.log('3' * '8') // number 24 
// console.log(4 + 10 + 'px') 14px 
// console.log('px' + 5 + 10) // string px510
// console.log('42' - 40) 2
// console.log('42px' - 2) NAN 
// console.log(null + 2) 2
// console.log(undefined + 42) NAN

// == vs ===
// console.log(2 == '2')
// console.log(2 === '2')
// console.log(undefined == null)
// console.log(undefined === null)
// console.log('0' == false)
// console.log('0' == 0)
// console.log(0 == 0)

// =====
console.log(false == '') true 
console.log(false == []) true 
console.log(false == {}) false 
console.log('' == 0) true
console.log('' == []) true 
console.log('' == {}) false 
console.log(0 == []) true
console.log(0 == {}) false 
console.log(0 == null) false 


Логически операторы 
ИЛИ ||
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (false), возвращает последний из них.


&& (И)
 alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
Оператор && выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

# 2  DOM

 **DOM** Объектная модель документа которая браузер создает на основе html кода. Дом имеет древовидную структуру его еще называют дом дерево
 Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.

Есть два основных набора ссылок:

Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.
Некоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому.

querySelector	
querySelectorAll	
getElementById	id	
getElementsByName	name
getElementsByTagName	
getElementsByClassName


 # 3  Контекст выполнения
  **This** 
 Контекст выполнения функции - значение переменной this внутри функции
При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
Эта функция может быть скопирована между объектами (из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является объект перед точкой.
Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри стрелочной функции обращаются к this, то его значение берётся снаружи.

**Декораторы и переадресация вызова, call/apply** 

Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.

func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как список аргументов. !!!!!


 **Привязка контента через bind**

Метод bind возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.

Обычно bind применяется для фиксации this в методе объекта, чтобы передать его в качестве колбэка. Например, для setTimeout.



# 4 замыкания
Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным.

«Лексическое окружение» – это специальный внутренний объект,который содержит свои локальные переменные и имеет ссылка на вшнешнее окружение  . 
- 1) окружение содержит свои локальные переменные и имеет ссылка на вшнешнее окружение
- 2) Сигналом для js чтобы создать новое окружение служат фигурные скобки 
- 3) Сначала js ищет переменные во внутреннем окружении, потом пытается найти их на уровне выше, потом в глобальном и т.д
# 5  прототипы
- В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null
- Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).
- Объект, на который ссылается [[Prototype]], называется «прототипом».
- Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
- Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
- Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
- Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.

**Методы прототипов, объекты без свойства __proto__**
Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. 
_proto- есть у всех объектов 
prototype - есть только у функций ( кроме стрелочной) и классов
- Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
- Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
- Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.

# 6  event Loop
Язык JS является однопоточным языком , в текущий момент времени может выполняться лишь одна задача. Если задача тяжело вестная, то мы не сможем приступить к другой задаче пока наша задача не выполниться. Even loop это бесконечный цикл который ожидает задачи , выполняет их и потом сново ожидает.
все синхронные задачи попадают в стек , и выполняются одна за другой , если мы наткаемся на асиннхронную задача с то она помещается в стек после чего переходит в webapi т после попадает в очерель и ожидает пока очистится стек для того чтобы туда попасть .




# 7 async/defer аттрибуты
Если мы подключаем скрипт к странице, то бразер не отресует нам HTML до тех пор пока не загрузится полностью скрипт. 
- async	Порядок загрузки (кто загрузится первым, тот и сработает). Не имеет значения. Может загрузиться и выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кеше, а документ достаточно большой.
- defer Порядок документа (как расположены в документе).Он загрузит скрипт но будет ждать пока не спарситься полностью Html файл и только потом выполниться скрипт
# 8 классы
В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).

Отличия от функции конструктора 
- 1 Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[FunctionKind]]:"classConstructor". Поэтому это не совсем то же самое, что создавать её вручную.
- 2 Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype".
- 3 Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

class MyClass {
  prop = value; // свойство
  constructor(...) { // конструктор
    // ...
  }
  method(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
  [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
  // ...
}

 **Наследовния классов** 
Для наследование одного класса от друго используется *Extends*
У классов есть ключевое слово "super" для таких случаев.

super.method(...) вызывает родительский метод.
super(...) вызывает родительский конструктор (работает только внутри нашего конструктора).
Чтобы унаследовать от класса: class Child extends Parent:
При этом Child.prototype.__proto__ будет равен Parent.prototype, так что методы будут унаследованы.
При переопределении конструктора:
Обязателен вызов конструктора родителя super() в конструкторе Child до обращения к this.
При переопределении другого метода:
Мы можем вызвать super.method() в методе Child для обращения к методу родителя Parent.
Внутренние детали:
Методы запоминают свой объект во внутреннем свойстве [[HomeObject]]. Благодаря этому работает super, он в его прототипе ищет родительские методы.
Поэтому копировать метод, использующий super, между разными объектами небезопасно.
Также:

У функций-стрелок нет своего this и super, поэтому они «прозрачно» встраиваются во внешний контекст.


Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса.В объявлении класса они помечаются ключевым словом static.

Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.

Синтаксис:

class MyClass {
  static property = ...;

  static method() {
    ...
  }
}
Технически, статическое объявление – это то же самое, что и присвоение классу:

MyClass.property = ...
MyClass.method = ...
Статические свойства и методы наследуются.

# 9 promises

 
- Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети.
- Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. 
Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе.

Аргументы
- resolve(value) — если работа завершилась успешно, с результатом value.
- reject(error) — если произошла ошибка, error – объект ошибки.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).

Первый аргумент метода **.then**– функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.
Вызов **.finally(f)** похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.