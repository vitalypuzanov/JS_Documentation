<h3>
  <img src="./assets/JavaScript.png" width="16" height="16" />
  <span>JavaScript:</span>
</h3> 

## ** This  ** 
Значение this определяется во время исполнения кода.

При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
Эта функция может быть скопирована между объектами (из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является объект перед точкой.
Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри стрелочной функции обращаются к this, то его значение берётся снаружи.


## ** Рекурсия  ** 
Рекурсия - термин обозначающий выозов функцией самой себя. 

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.


## ** Остаточные параметры, параметры расширения  (...) ** 
Остаточные параметры позволяют собрать параметры которые изначально были не заданы в массив. Обозначается как (...arg(название массива))

![](images/ostatochnie.png)

Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива

С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.

![](images/rasshirenie.png)


## ** Замыкание  ** 
Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
Замыкание напрямую связанно с лексическим окружением и [[Environment]].
«Лексическое окружение» – это специальный внутренний объект.
- Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.
- Работа с переменными – это на самом деле работа со свойствами этого объекта.

## ** Переменная Var **

Существует 2 основных отличия var от let/const:

Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
Объявления (инициализация) переменных var производится в начале исполнения функции (или скрипта для глобальных переменных).


## ** Глобальный объект  ** 
глобальный объект представляет переменные и функции доступные в любом месте программы.  браузере он называется window, в Node.js — global 

## ** Способы объявления функции  ** 
1*Function Declaration*
function sayHi() {
  alert("Hello");
}

2*Function Expression*
var sayHi = function () {
  alert("Hello");
};

3 *Named Function Expression*
var sayHi = function foo() {
  alert("Hello");
};

4*"new Function"*
let sum = new Function('a', 'b', 'return a + b');

alert( sum(1, 2) ); // 3



## ** Планирование: setTimeout и setInterval  ** 

- setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
![](images/settimaout.png)


- setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

-Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением, которое возвращают методы setInterval/setTimeout.
Вложенный вызов setTimeout является более гибкой альтернативой setInterval. Также он позволяет более точно задать интервал между выполнениями.

## ** Декораторы и переадресация вызова, call/apply  ** 

Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.

func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как список аргументов. !!!!!


## ** Привязка контента через bind  **

Метод bind возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.

Обычно bind применяется для фиксации this в методе объекта, чтобы передать его в качестве колбэка. Например, для setTimeout.

![](images/bind.png)

## ** Флаги и дескрипторы свойств  **

-writable – если true, свойство можно изменить, иначе оно только для чтения.
-enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
-configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

Метод ***Object.getOwnPropertyDescriptor*** позволяет получить полную информацию о свойстве.
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);

Существует метод Object.defineProperties(obj, descriptors), который позволяет определять множество свойств сразу.
![](images/proper.png)



## ** Свойства - геттеры и сеттеры  **
Сущесвует два типа свойсвт 1) Свойства - значения и 2)Cвойства-аксессоры (accessor properties). По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.

Ддескриптор аксессора может иметь:

- **get** – функция без аргументов, которая сработает при чтении свойства,
- **set** – функция, принимающая один аргумент, вызываемая при присвоении свойства,
- enumerable – то же самое, что и для свойств-данных,
- configurable – то же самое, что и для свойств-данных.

Свойства-аксессоры не имеют value и writable
![](images/hide.png)



## **Прототипы и наследования**
- В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null
- Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).
- Объект, на который ссылается [[Prototype]], называется «прототипом».
- Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
- Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
- Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
- Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.


## ** Методы прототипов, объекты без свойства __proto__  **
Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. 
_proto- есть у всех объектов 
prototype - есть только у функций ( кроме стрелочной) и классов
- Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
- Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
- Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.


## ** Классы  **
В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).

Отличия от функции конструктора 
- 1 Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[FunctionKind]]:"classConstructor". Поэтому это не совсем то же самое, что создавать её вручную.
- 2 Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype".
- 3 Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

class MyClass {
  prop = value; // свойство
  constructor(...) { // конструктор
    // ...
  }
  method(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
  [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
  // ...
}

 ## Наследовния классов 
Для наследование одного класса от друго используется *Extends*