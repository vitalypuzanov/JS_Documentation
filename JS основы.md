<h3>
  <img src="https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/javascript/javascript.png" width="16" height="16" />
  <span>JavaScript:</span>
</h3> 


## Типы данных 
В JS существует 8 типов данных и 2 группы - примитивы и сложные структуры:
- number число (целые и с плавующей точкой) до 2 в 53 степени
- bigint для целых чисел большой длинны 
- string строка
- boolean (true/fakse)
- null дле неизвестных значений 
- undefind для неприсвоенных значений 
- symbol уникалный модификатор 
- object сложный тип 

*Вопросы по этой теме*
1. **Чем отличается null от undefind ?**

Undefind - переменная инициализирована, но значение ей не задано, а null устанавливается самостоятельно. 

2. **Как узнать тип данных ?**

type of


## Преобразование типов
Для численных преоброзований :

![numbers](./1.png)

Для логических преоброзований:
- Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
- Все остальные значения становятся true.

### Строки и числа

      console.log(1 + '2')  string 12
      console.log('' + 1 + 0) строка 10
      console.log('' - 1 + 0) -1 
      console.log('3' * '8')> number 24 
      console.log(4 + 10 + 'px') 14px 
      console.log('px' + 5 + 10)  string px510
      console.log('42' - 40) 2
      console.log('42px' - 2) NAN 
      console.log(null + 2) 2
      console.log(undefined + 42) NAN


      console.log(2 == '2')
      console.log(2 === '2')
      console.log(undefined == null)
      console.log(undefined === null)
      console.log('0' == false)
      console.log('0' == 0)
      console.log(0 == 0)


      console.log(false == '') true 
      console.log(false == []) true 
      console.log(false == {}) false 
      console.log('' == 0) true
      console.log('' == []) true 
      console.log('' == {}) false 
      console.log(0 == []) true
      console.log(0 == {}) false 
      console.log(0 == null) false 


## Типы сравнения 
Существуют следующие типы сравнения:
- Больше/меньше: a > b, a < b.
- Больше/меньше или равно: a >= b, a <= b.
- Равно: a == b. Обратите внимание, для сравнения используется двойной знак равенства ==. Один знак равенства a = b означал бы присваивание.
- Не равно. В математике обозначается символом ≠, но в JavaScript записывается как a != b.

*Вопросы по этой теме*
1. **Чем отличается == и === ?**

Двойное равно это сравнение с приведением к единому типу, Тройное равно это строгое сравнение без приведения типов.

2. **Что выведет консоль при null==undefind и null===udefind ?**

True, False 

## Логические операторы
В JavaScript есть три логических оператора:
 || (ИЛИ)
 && (И) 
 ! (НЕ)

1. **ИЛИ ||**

![||](./2.png)


- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (false), возвращает последний из них.


2. **&& (И)**

![||](./3.png)


- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.



##  This   
Значение this определяется во время исполнения кода.

При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
Эта функция может быть скопирована между объектами (из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является объект перед точкой.
Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри стрелочной функции обращаются к this, то его значение берётся снаружи.


##  Рекурсия   
Рекурсия - термин обозначающий выозов функцией самой себя. 

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.


##  Остаточные параметры, параметры расширения  (...)  
Остаточные параметры позволяют собрать параметры которые изначально были не заданы в массив. Обозначается как (...arg(название массива))

![](images/ostatochnie.png)

Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива

С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.

![](images/rasshirenie.png)


##  Замыкание  
Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
Замыкание напрямую связанно с лексическим окружением и [[Environment]].
«Лексическое окружение» – это специальный внутренний объект.
- Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.
- Работа с переменными – это на самом деле работа со свойствами этого объекта.

##  Переменная Var 

Существует 2 основных отличия var от let/const:

Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
Объявления (инициализация) переменных var производится в начале исполнения функции (или скрипта для глобальных переменных).


## Глобальный объект   
глобальный объект представляет переменные и функции доступные в любом месте программы.  браузере он называется window, в Node.js — global 

##  Способы объявления функции   
1*Function Declaration*
function sayHi() {
  alert("Hello");
}

2*Function Expression*
var sayHi = function () {
  alert("Hello");
};

3 *Named Function Expression*
var sayHi = function foo() {
  alert("Hello");
};

4*"new Function"*
let sum = new Function('a', 'b', 'return a + b');

alert( sum(1, 2) ); // 3



##  Планирование: setTimeout и setInterval  

- setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
![](images/settimaout.png)


- setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

-Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением, которое возвращают методы setInterval/setTimeout.
Вложенный вызов setTimeout является более гибкой альтернативой setInterval. Также он позволяет более точно задать интервал между выполнениями.

##  Декораторы и переадресация вызова, call/apply   

Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.

func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как список аргументов. !!!!!


##  Привязка контента через bind  

Метод bind возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.

Обычно bind применяется для фиксации this в методе объекта, чтобы передать его в качестве колбэка. Например, для setTimeout.

![](images/bind.png)

##  Флаги и дескрипторы свойств  

-writable – если true, свойство можно изменить, иначе оно только для чтения.
-enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
-configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

Метод ***Object.getOwnPropertyDescriptor*** позволяет получить полную информацию о свойстве.
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);

Существует метод Object.defineProperties(obj, descriptors), который позволяет определять множество свойств сразу.
![](images/proper.png)



##  Свойства - геттеры и сеттеры  
Сущесвует два типа свойсвт 1) Свойства - значения и 2)Cвойства-аксессоры (accessor properties). По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.

Ддескриптор аксессора может иметь:

- **get** – функция без аргументов, которая сработает при чтении свойства,
- **set** – функция, принимающая один аргумент, вызываемая при присвоении свойства,
- enumerable – то же самое, что и для свойств-данных,
- configurable – то же самое, что и для свойств-данных.

Свойства-аксессоры не имеют value и writable
![](images/hide.png)



## **Прототипы и наследования**
- В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null
- Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).
- Объект, на который ссылается [[Prototype]], называется «прототипом».
- Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
- Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
- Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
- Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.


##  Методы прототипов, объекты без свойства __proto__  
Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. 
_proto- есть у всех объектов 
prototype - есть только у функций ( кроме стрелочной) и классов
- Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
- Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
- Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.


##  Классы  
В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).

Отличия от функции конструктора 
- 1 Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[FunctionKind]]:"classConstructor". Поэтому это не совсем то же самое, что создавать её вручную.
- 2 Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype".
- 3 Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

class MyClass {
  prop = value; // свойство
  constructor(...) { // конструктор
    // ...
  }
  method(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
  [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
  // ...
}

 ## Наследовния классов 
Для наследование одного класса от друго используется *Extends*
